#!/usr/bin/env python
# input parameters are: number of MC runs, index in the s&p500./cv file, Quandl API key
# the file s&p500.csv should be in the same directory
# the output file is produced in the directory /tmp/outdata in the format <company symbol>.csv
# each output file includes a random position (number of shares) between 1000 and 10000

# install tkinter
import argparse
from os import path, makedirs
import math
import csv
from random import randint
import time
import numpy as np
import quandl
import matplotlib.pyplot as plt


TRADING_DAYS = 252  # Number of trading days on stock
OUTPUT_DIR = path.join(path.dirname(path.abspath(__file__)), 'outputs')


class DataPlot(object):
    def __init__(self, data):
        self._figure, self._axis = plt.subplots()
        for row in data:
            self._axis.plot(row[4:])

    def show_plot(self):
        plt.show()

    def save_plot(self, file_path):
        self._figure.savefig(file_path)


def save_to_csv(data, file_path):
    output_dir = path.dirname(file_path)
    if not path.exists(output_dir):
        makedirs(output_dir)
    with open(file_path, 'wb') as outfile:
        csv_writer = csv.writer(outfile)
        for row in data:
            csv_writer.writerow(row)


def get_data(company, iter_count, start_date):
    # time.sleep(randint(0, 4))
    marketd = quandl.get('WIKI/%s' % company, start_date=start_date)

    # calculate the compound annual growth rate (CAGR) which
    # will give us our mean return input (mu)
    days = (marketd.index[-1] - marketd.index[0]).days
    cagr = (marketd['Close'][-1] / marketd['Close'][1]) ** (365.0 / days) - 1

    # create a series of percentage returns and calculate
    # the annual volatility of returnsgoogle_quandl
    marketd['Returns'] = marketd['Close'].pct_change()
    vol = marketd['Returns'].std() * np.sqrt(TRADING_DAYS)
    # print("Annual Volatility =",str(round(vol,4)*100)+"%")

    starting_price = marketd['Close'][-1]  # starting company price (i.e. last available real company price)
    # mu = 0.2309 #Returniter_count
    # vol = 0.4259 #Volatility

    position = randint(10, 1000) * 10

    data =[]
    for i in xrange(iter_count):
        # create list of daily returns using random norgoogle_quandlmal distribution
        daily_returns = np.random.normal(cagr/TRADING_DAYS, vol/math.sqrt(TRADING_DAYS), TRADING_DAYS) + 1
        # set starting price and create price series generated by above random daily returns
        price_list = [company, position, i, starting_price]
        for x in daily_returns:
            price_list.append(price_list[-1] * x)
        data.append(price_list)

    return data


def _parse_args():
    parser = argparse.ArgumentParser('randomwalk', description='Monte-Carlo simulation for stock prices behaviour '
                                                               'based on data from www.quandl.com')
    parser.add_argument('-n', '--snum', required=True, type=int, default=1000,
                        help='number of simulations (default:%(default)s)')
    parser.add_argument('-c', '--company', required=True,
                        help='company symbol on stock (i. e. WDC)')
    parser.add_argument('-t', '--quandl-token', help='get token from www.quandl.com')
    parser.add_argument('-s', '--start-date', default='2018-01-01', help='example: %(default)s')
    parser.add_argument('-o', '--output-dir', default=path.join(path.dirname(path.abspath(__file__)), 'outputs'))
    parser.add_argument('--plot', choices=('show', 'save'), help='show plot / save plot to .png')
    return parser.parse_args()


def main():
    args = _parse_args()
    if args.quandl_key:
        quandl.ApiConfig.api_key = args.quandl_key
    data = get_data(args.company, args.iter_count, args.start_date)
    save_to_csv(data, path.join(OUTPUT_DIR, '%s.csv' % args.company))
    if args.plot:
        plot = DataPlot(data)
        if args.plot == 'show':
            plot.show_plot()
        if args.plot == 'save':
            plot.save_plot(path.join(OUTPUT_DIR, '%s.png' % args.company))


if __name__ == '__main__':
    main()
